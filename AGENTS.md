# AGENTS.md

This file provides instructions for AI coding agents working on this repository.

---

## Comment & Output Restraint

Keep output and code/doc comments minimal and purposeful.

- Do NOT add progress logs, narrative explanations, or meta commentary to source code, docs, tests, or commit diffs.
- No autogenerated banners or markers like "Generated by".
- Never use emojis in code, comments, documentation, or commit messages.
- Inline comments only when they clarify non-obvious intent, business rules, performance trade-offs, or security rationale. Omit comments that restate the code.
- Remove obsolete/stale comments when changing related code.
- Avoid speculative TODOs; only leave a TODO if it is immediately actionable, clearly scoped, and required. Prefer creating a tracked issue instead.
- Do not insert review-style remarks ("nit:", "consider:") inside committed files.
- Keep examples free of progress chatter: only the example code and essential annotations.

---

## Workflow Principles

- **Correctness first:** Prioritize correctness, then readability/maintainability, then performance.
- **Reflect before acting:** After tool results, briefly summarize insights, list next options, and pick the best one.
- **Parallelize independent steps:** Run unrelated reads/checks in parallel to maximize efficiency.
- **No leftovers:** Remove temporary files/scripts/debug outputs before finishing. Keep `git status` clean aside from intended changes.
- **Ask when unsure:** If requirements are ambiguous, seek clarification rather than guessing.
- **Well-supported dependencies:** Prefer widely used, well-documented libraries with active maintenance. Ask permission before adding new dependencies.
- **Security first:** Never exfiltrate secrets; avoid network calls unless explicitly required. Do not log PII or secrets.
- **After editing code:** Run `go build ./...`, `go test ./...`, and `golangci-lint run ./...` to ensure build/test/lint compliance.

---

## Project Overview

Echo Playground is a minimal REST API skeleton built with [Echo v5](https://github.com/labstack/echo/tree/v5). It demonstrates structured logging, RFC 9457 Problem Details for errors, and a modular route layout.

### Key Features

- Echo v5 middleware stack with security headers, CORS, request IDs, real IP detection, request logging, access logging, and panic recovery
- Request-scoped slog logger with Google Cloud trace metadata enrichment
- Plain response bodies with RFC 9457 Problem Details for errors
- Content negotiation supporting JSON and CBOR formats
- Cursor-based pagination with RFC 8288 Link headers
- Firebase Authentication with JWT validation via Echo middleware
- Firestore integration with transaction-safe CRUD operations and audit logging
- go-playground/validator for request validation
- swaggo/swag v2 for OpenAPI 3.1 documentation

### Tech & Tooling

- Language/runtime: Go 1.25+
- Frameworks/libs: Echo v5, go-playground/validator, fxamacker/cbor, Firebase Admin SDK
- Logging: log/slog (stdlib)
- Testing: Go standard `testing` package, echotest, Firebase Emulators
- OpenAPI: swaggo/swag v2 (OAS 3.1)
- Task runner: [Just](https://github.com/casey/just) (optional)
- Firebase CLI: Required for emulators (`just emulators`)

---

## Justfile

The project includes a `Justfile` for common development tasks. Run `just` to list available commands.

Key recipes:
- `just build` - Build the application
- `just run` - Run the server
- `just test` - Run all tests
- `just coverage` - Run tests and generate coverage report
- `just lint` - Run linter
- `just fmt` - Apply formatters
- `just fix` - Run linter and apply formatters
- `just check` - Full check (build + test + lint)
- `just qa` - Quality assurance (tidy + fix + build + test)
- `just vuln` - Check for vulnerabilities
- `just install` - Download module dependencies (alias for download)
- `just fresh` - Recreate project from clean state
- `just emulators` - Start Firebase emulators (Auth + Firestore)
- `just docs` - Generate OpenAPI 3.1 spec (alias for gen-openapi)
- `just gen-openapi` - Generate OpenAPI 3.1 spec
- `just fmt-openapi` - Format swag annotations

All commands in this document can be run via their corresponding `just` recipes.

---

## Setup

### Requirements

- Go 1.25+
- Firebase CLI (for emulators): `npm install -g firebase-tools`

### Install Dependencies

```bash
go mod download
```

### Build

```bash
go build -v ./...
```

### Run

```bash
go run ./cmd/server
```

The server starts on port 8080 with endpoints:
- `http://localhost:8080/health` - health probe
- `http://localhost:8080/api-docs` - Swagger UI
- `http://localhost:8080/api-docs/openapi.json` - OpenAPI 3.1 spec

---

## Testing

Run all tests:

```bash
go test ./...
```

Run tests with verbose output:

```bash
go test -v ./...
```

Run tests with coverage:

```bash
go test -v -covermode=atomic -coverpkg=./... -coverprofile=coverage.out ./...
```

Generate coverage report:

```bash
go tool cover -func=coverage.out
go tool cover -html=coverage.out -o coverage.html
```

---

## Linting

The project uses [golangci-lint](https://golangci-lint.run/) v2 for static analysis and code formatting. Configuration is defined in `.golangci.yml`.

Run linter:

```bash
golangci-lint run ./...
```

Apply formatters (gci, gofumpt, golines) automatically:

```bash
golangci-lint fmt ./...
```

Run linter and apply formatters in one step:

```bash
golangci-lint run --fix ./...
```

---

## Project Structure

```
cmd/server/            # Application entrypoint and HTTP server bootstrap
api-docs/              # Generated OpenAPI 3.1 spec (swagger.json, swagger.yaml, docs.go)
internal/http/         # HTTP transport layer
  docs/                # Swagger UI serving and spec route registration
  health/              # Health check handler (unversioned)
  v1/                  # Versioned API (v1)
    hello/             # Hello endpoint handlers
    items/             # Items endpoint handlers
    profile/           # Profile endpoint handlers (requires auth)
    routes/            # Route registration
internal/platform/     # Cross-cutting infrastructure
  auth/                # Firebase Auth middleware and JWT validation
  firebase/            # Firebase Admin SDK initialization
  logging/             # Structured logging with slog
  middleware/          # Security headers, CORS, request ID
  pagination/          # Cursor-based pagination
  respond/             # Panic recovery, Problem Details, content negotiation
  timeutil/            # Time formatting utilities
  validate/            # go-playground/validator integration
internal/service/      # Business logic and data access
  profile/             # Profile service with Firestore backend
internal/testutil/     # Test utilities (emulator helpers)
```

---

## Architecture Principles

### Platform Layer

The `internal/platform/` packages provide shared infrastructure used by HTTP handlers. These packages are organized by concern rather than transport:

| Package | Purpose | Dependencies |
|---------|---------|--------------|
| `auth` | Firebase JWT validation, user context, Echo security middleware | Firebase Admin SDK, Echo |
| `firebase` | Firebase Admin SDK initialization (Auth + Firestore clients) | Firebase Admin SDK |
| `logging` | Structured logging, request-scoped context, trace correlation, audit logging | slog, Echo (for HTTP middleware) |
| `middleware` | HTTP middleware (CORS, security headers, request ID, vary) | Echo |
| `pagination` | Cursor encoding/decoding, link header generation | Standard library only |
| `respond` | Panic recovery, Problem Details error responses, content negotiation | Echo, fxamacker/cbor |
| `timeutil` | Time formatting constants | Standard library only |
| `validate` | Request validation via go-playground/validator | go-playground/validator, Echo |

**Truly transport-agnostic packages:**
- `pagination` - Cursor logic works for any transport
- `timeutil` - Time formatting has no transport coupling

**HTTP-coupled packages (by design):**
- `logging` - HTTP middleware for request logging; core helpers (`LogInfo`, `LogError`) are transport-agnostic
- `middleware` - HTTP-specific (CORS, headers, request ID)
- `respond` - HTTP error handling with RFC 9457 Problem Details

**Key rule:** Platform packages must not import from `internal/http/` (no circular dependencies). HTTP handlers import platform packages, never the reverse.

---

## Coding Conventions

### Handler Signature

All handlers use Echo v5's pointer-to-concrete-struct signature:

```go
func handler(c *echo.Context) error {
    // ...
}
```

### Response Format

Responses use `respond.Negotiate()` for content negotiation (JSON/CBOR):

```go
func getHandler(c *echo.Context) error {
    return respond.Negotiate(c, http.StatusOK, Data{Message: "Hello, World!"})
}
```

### Input Binding and Validation

Use `c.Bind()` + `c.Validate()` with struct tags:

```go
func createHandler(c *echo.Context) error {
    var input CreateInput
    if err := c.Bind(&input); err != nil {
        return err
    }
    if err := c.Validate(&input); err != nil {
        return err
    }
    // process input...
}
```

### Input Struct Tags

- Body fields: `json:"name" validate:"required,min=1,max=100"`
- Query params: `query:"limit" validate:"omitempty,min=1,max=100"`
- Path params: `param:"id" validate:"required"`

### Error Handling

Errors follow RFC 9457 Problem Details and honor content negotiation:
- `application/problem+json` when JSON is requested (default, RFC 9457 registered)
- `application/problem+cbor` when CBOR is requested (project extension, follows RFC 6839 suffix convention)

Use custom error helpers:

```go
import "github.com/janisto/echo-playground/internal/platform/respond"

respond.Error400("invalid request")
respond.Error401("unauthorized")
respond.Error403("access denied")
respond.Error404("resource not found")
respond.Error409("resource already exists")
respond.Error422("validation failed", fieldErrors...)
respond.Error500("internal error")
respond.NewError(http.StatusTeapot, "custom message")
```

Panic recovery and Echo-level handlers use Problem Details via `internal/platform/respond`.

### Logging

Use context-aware logging helpers from `internal/platform/logging`:

```go
import (
    "log/slog"
    applog "github.com/janisto/echo-playground/internal/platform/logging"
)

applog.LogInfo(ctx, "message", slog.String("key", "value"))
applog.LogWarn(ctx, "message", slog.String("key", "value"))
applog.LogError(ctx, "message", err, slog.String("key", "value"))
applog.LogFatal(ctx, "message", err, slog.String("key", "value"))
```

These helpers preserve contextual fields such as trace IDs.

### Adding New Routes

1. Create a new directory under `internal/http/v1/` (e.g., `users/`)
2. Create `handler.go` with `Register(g *echo.Group)` function
3. Create `input.go` with input structs using `validate` tags
4. Create `model.go` with response model structs
5. Add swag annotations to handler functions (see [OpenAPI Documentation](#openapi-documentation))
6. Call `Register()` from `routes.Register()`
7. Log within handlers using context-aware helpers
8. Return errors using respond error helpers
9. Regenerate the OpenAPI spec: `just docs`

### POST 201 Created Pattern

```go
func createHandler(c *echo.Context) error {
    var input CreateInput
    if err := c.Bind(&input); err != nil {
        return err
    }
    if err := c.Validate(&input); err != nil {
        return err
    }

    resource := createResource(input)
    c.Response().Header().Set("Location", fmt.Sprintf("/resources/%s", resource.ID))
    return respond.Negotiate(c, http.StatusCreated, resource)
}
```

### JSON Encoding

- JSON responses are UTF-8
- CBOR responses use `application/cbor` content type

---

## REST API Implementation Guidelines

### URI Design

- Use plural nouns for collections (`/users`, not `/user`)
- Avoid verbs in URIs; let HTTP methods convey the action
- Nest resources to express relationships (`/posts/{postId}/comments`); limit nesting to one level
- Use lowercase with hyphens for multi-word segments (`/user-profiles`)

### Input Validation

- Validate all input; never sanitize (reject invalid input, don't transform it)
- Use go-playground/validator tags (`required`, `min`, `max`, `oneof`, `email`, `e164`)
- Return 400 for malformed syntax; 422 for validation failures on valid syntax

### HTTP Methods

| Method | Purpose | Success Status |
|--------|---------|----------------|
| GET | Retrieve resource(s) | 200 OK |
| POST | Create a resource | 201 Created |
| PUT | Replace a resource entirely | 200 OK or 204 No Content |
| PATCH | Partial update | 200 OK or 204 No Content |
| DELETE | Remove a resource | 204 No Content |

### Status Codes

| Status | Use Case |
|--------|----------|
| 200 OK | Successful GET, PUT, PATCH |
| 201 Created | Successful POST (include Location header) |
| 204 No Content | Successful DELETE |
| 400 Bad Request | Malformed syntax, missing required fields |
| 401 Unauthorized | Missing or invalid authentication |
| 403 Forbidden | Authenticated but not authorized |
| 404 Not Found | Resource does not exist |
| 405 Method Not Allowed | HTTP method not supported for resource |
| 422 Unprocessable Entity | Validation failures on specific fields |
| 500 Internal Server Error | Unexpected server error |

### Error Responses

All errors use RFC 9457 Problem Details format:

```json
{
  "type": "about:blank",
  "title": "Not Found",
  "status": 404,
  "detail": "resource not found"
}
```

### Request ID

- `X-Request-ID` header tracks requests end-to-end
- Propagate to downstream services and include in logs
- Generated automatically by RequestID middleware if not provided

### Content Types

**Requests:**
- Set `Content-Type: application/json` for JSON request bodies
- Set `Content-Type: application/cbor` for CBOR request bodies

**Responses:**
- Default: `application/json` (RFC 8259)
- Alternate: `application/cbor` (RFC 8949)
- Errors: `application/problem+json` (RFC 9457) or `application/problem+cbor` (extension)
- Format selected via `Accept` header
- Error format is controlled by `Accept` header, not request `Content-Type`

### Timestamps

- Use ISO 8601 / RFC 3339 format with UTC timezone and millisecond precision: `2024-01-15T10:30:00.000Z`
- Use `timeutil.Time` wrapper for JSON responses to ensure consistent `.000Z` output
- Use `timeutil.RFC3339Millis` constant for formatting: `time.Now().UTC().Format(timeutil.RFC3339Millis)`
- Go uses a reference time for format strings: `2006-01-02T15:04:05.000Z` (Jan 2, 2006 15:04:05)
- Store and transmit in UTC; convert for display only

### Pagination

Use cursor-based pagination via `internal/platform/pagination`. Invalid cursors must return 400 Bad Request per JSON:API cursor pagination best practices.

Links provided via HTTP `Link` header per RFC 8288.

---

## Testing Guidelines

### Test Structure

- Tests are colocated with source files using `_test.go` suffix
- Use Go's standard `testing` package
- Use `echotest` package for handler unit tests
- Use `e.ServeHTTP()` for integration tests

### Integration Test Pattern

```go
func TestMyFeature(t *testing.T) {
    e := echo.New()
    e.Validator = validate.New()
    e.HTTPErrorHandler = respond.NewHTTPErrorHandler()
    e.Use(middlewares...)
    v1 := e.Group("/v1")
    routes.Register(v1, verifier, svc)

    req := httptest.NewRequest(http.MethodGet, "/v1/hello", nil)
    req.Header.Set("X-Request-ID", "test-trace-id")
    rec := httptest.NewRecorder()

    e.ServeHTTP(rec, req)

    if rec.Code != http.StatusOK {
        t.Fatalf("expected 200 OK, got %d", rec.Code)
    }
}
```

### Handler Unit Test Pattern (echotest)

```go
rec := echotest.ContextConfig{
    Request:     httptest.NewRequest(http.MethodGet, "/items?limit=10", nil),
    QueryValues: url.Values{"limit": {"10"}},
}.ServeWithHandler(t, handler, respond.NewHTTPErrorHandler())
```

### Error Response Testing

```go
var problem respond.ProblemDetails
if err := json.Unmarshal(rec.Body.Bytes(), &problem); err != nil {
    t.Fatalf("failed to unmarshal problem: %v", err)
}
if problem.Status != http.StatusNotFound {
    t.Fatalf("expected 404, got %d", problem.Status)
}
```

### Coverage Requirements

- Tests should cover success paths, error paths, and edge cases
- Verify error responses use Problem Details format
- Test trace ID propagation through the request context

### Firebase Emulator Testing

Firestore integration tests require running emulators. Start them before running tests:

```bash
just emulators
```

Emulator configuration (from `firebase.json`):
| Service | Port |
|---------|------|
| Auth | 7110 |
| Functions | 7120 |
| Firestore | 7130 |
| Storage | 7140 |
| Emulator UI | 4000 |

Tests auto-skip when emulators are unavailable. The `demo-test-project` project ID triggers emulator-only mode (SDK will only communicate with local emulators).

---

## Testing & Testability

- **NEVER add test-related code to production code.** No `if testing` branches, no test flags, no mock injection points.
- If code is not unit testable, refactor it. Use dependency injection, extract interfaces, or restructure. Do not pollute production code with test scaffolding.
- Tests belong in `*_test.go` files; production code must remain test-agnostic.

---

## Secrets & Environment Variables

- Never commit secrets. Use environment variables for configuration.
- Access config through environment variables; don't hardcode secrets in business logic.
- Don't log secrets or PII; ensure logs redact sensitive fields.
- Typical env vars:
  - `FIREBASE_PROJECT_ID` (use `demo-*` prefix for emulator-only mode in development)
  - `GOOGLE_APPLICATION_CREDENTIALS` (path to service account JSON; uses ADC if not set)
  - `GOOGLE_CLOUD_PROJECT`, `GCP_PROJECT`, `GCLOUD_PROJECT`, or `PROJECT_ID` (for Cloud Trace correlation)

---

## Authentication

### Protected Endpoints

Use Echo group-level middleware for protected routes:

```go
import "github.com/janisto/echo-playground/internal/platform/auth"

func Register(v1 *echo.Group, verifier auth.Verifier, svc profilesvc.Service) {
    protected := v1.Group("", auth.Middleware(verifier))
    profile.Register(protected, svc)
}
```

### Accessing User in Handlers

The auth middleware sets the user in Echo context for secured endpoints:

```go
func handleGetProfile(c *echo.Context) error {
    user, err := auth.UserFromEchoContext(c)
    if err != nil {
        return respond.Error401("unauthorized")
    }
    // user is guaranteed non-nil for secured endpoints because the auth
    // middleware rejects unauthenticated requests before reaching the handler
    return respond.Negotiate(c, http.StatusOK, Profile{ID: user.UID})
}
```

---

## OpenAPI Documentation

The project uses [swaggo/swag v2](https://github.com/swaggo/swag/tree/v2) to generate an OpenAPI 3.1 spec from Go comment annotations. The CLI is installed as a Go tool dependency (`go tool swag`).

### Generated files

| File | Purpose |
|------|---------|
| `api-docs/swagger.json` | OpenAPI 3.1 spec (JSON), served at `/api-docs/openapi.json` |
| `api-docs/swagger.yaml` | Same spec in YAML |
| `api-docs/docs.go` | Swag registry (auto-generated, not imported by the app) |

### Generating the spec

```bash
just docs
```

or equivalently:

```bash
go tool swag init --v3.1 --parseInternal -g cmd/server/main.go -o api-docs
```

`--parseInternal` is required because all handlers live under `internal/`.

### Formatting annotations

```bash
just fmt-openapi
```

This auto-aligns `// @` annotations. Run before `just docs` after manual annotation edits.

### When to regenerate

Regenerate after any of these changes:
- Adding, removing, or renaming handler functions or routes
- Modifying `// @` annotations (summary, params, responses, security)
- Changing request/response struct fields or tags (`json`, `example`, `validate`)
- Updating general API info in `cmd/server/main.go`

### Annotation conventions

- General API info (`@title`, `@servers.url`, `@securityDefinitions.apikey`) lives in `cmd/server/main.go`.
- Operation annotations (`@Summary`, `@Param`, `@Success`, `@Failure`, `@Security`, `@Router`) go on the handler function.
- Do NOT use `@Accept json` on handler annotations. swag v2 has a bug ([swaggo/swag#2142](https://github.com/swaggo/swag/issues/2142)) where `@Accept json` combined with `@Param body` generates a `oneOf` with an empty object schema, breaking Swagger UI examples. swag defaults to `application/json` for body params, so omitting `@Accept` produces the correct spec.
- Use `@Produce json,application/cbor` for endpoints supporting content negotiation.
- Use `@Failure` with `respond.ProblemDetails` for error responses.
- Use `@Security BearerAuth` on protected routes.
- The generated `api-docs/` files must be committed.

### Swagger UI

Swagger UI is served via an embedded HTML page in `internal/http/docs/`. Routes are registered in `cmd/server/main.go` via `docs.Register(e, "api-docs/swagger.json")`.

| URL | Purpose |
|-----|---------|
| `/api-docs` | Swagger UI |
| `/api-docs/openapi.json` | Raw OpenAPI 3.1 spec |

---

## Restrictions

- Never commit secrets or sensitive data
- Do not modify `go.mod` or `go.sum` without explicit request
- Use respond error helpers for error responses
- Do not add new dependencies without justification

---

## Agent Execution Guardrails

- Reflect on tool results and pick the best next action before proceeding.
- Prefer batching independent read-only steps in parallel; avoid redundant reads.
- Clean up temporary files/scripts before finishing a task.
- Do not invent paths/APIs/commands. Verify from repo or tooling.
- For runnable code changes, run minimal tests to validate, report PASS/FAIL succinctly, and iterate up to three targeted fixes if needed.
